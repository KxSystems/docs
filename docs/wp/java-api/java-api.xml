<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article>
<article
  xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xlink="http://www.w3.org/1999/xlink" >
  <info>
    <title>Java API for kdb+</title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Lyness</surname>
      </author>
    </authorgroup>
    <date>May 2018</date>
    <keywords>API, Java, interface, connection</keywords>
  </info>
<section xml:id="java-api-for-kdb">
  <title>Java API for kdb+</title>
  <para>
    The Java programming language has been consistently popular for two
    decades, and is important in many development environments. Its
    longevity, and the compatibility of code between versions and
    operating systems, leaves the landscape of Java applications in many
    industries very much divided between new offerings and
    long-established legacy code.
  </para>
  <para>
    Financial technology is no exception. Competition in this
    risk-averse domain drives it to push against boundaries. Production
    systems inevitably mix contemporary and legacy code. Because of
    this, developers need tools for communication and integration.
    Implementation risks must be kept to a strict minimum. Kx technology
    is well-equipped for this issue. By design kdb+’s communication with
    external processes is kept simple, and reinforced with interface
    libraries for other languages.
  </para>
  <para>
    The Java API for kdb+ is a Java library. It fits easily in any Java
    application as an interface to kdb+ processes. As with any API,
    potential use cases are many. To introduce kdb+ gradually into a
    wider system, such an interface is essential for any interaction
    with Java processes, upstream or downstream. The straightforward
    implementation keeps changes to legacy code lightweight, reducing
    the risk of wider system issues arising as kdb+ processes are
    introduced.
  </para>
  <para>
    This paper illustrates how the Java API for kdb+ can be used to
    enable a Java program to interact with a kdb+ process. It first
    explores the API itself: how it is structured, and how it might be
    included in a development project. Examples are then provided for
    core use cases for the API in a standard setup. Particular
    consideration is given to how the API facilitates subscription and
    publication to a kdb+ tickerplant process, a core component of any
    kdb+ tick-capture system.
  </para>
  <para>
    The examples presented here form a set of practical templates
    complementary to the
    <link xlink:href="/interfaces/java-client-for-q">primary source of
    information</link> on code.kx.com. These templates can be combined
    and adapted to apply kdb+ across a broad range of problem domains.
    They are available on <i class="fa fa-github"></i>
    <link xlink:href="https://github.com/kxcontrib/javaapi">GitHub</link>.
  </para>
</section>
<section xml:id="api-overview">
  <title>API overview</title>
  <para>
    The API is contained in a <i class="fa fa-github"></i>
    <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java">single
    source file</link> on GitHub. Inclusion in a development project is,
    therefore, a straightforward matter of including the file with other
    source code under the package <literal>kx</literal>, and ensuring it
    is properly imported and referenced by other classes. If preferred,
    it can be compiled separately into a class or JAR file to be
    included in the classpath for use as an external library or uploaded
    to a local repository for build integration.
  </para>
  <para>
    As the API is provided as source, it is perfectly possible to
    customize code to meet specific requirements. However, without prior
    knowledge of how the interactions work, this is not advised unless
    the solution to these requirements or issues are known. It is also
    possible, and in some contexts encouraged, to wrap the functionality
    of this class within a model suitable for your framework. An example
    might be the open-source <i class="fa fa-github"></i>
    <link xlink:href="https://github.com/exxeleron/qJava">qJava
    library</link>. Although it is not compatible with the most recent
    kdb+ version at the time of writing, it shows how to use
    <literal>c.java</literal> as a core over which an object-oriented
    framework of q types and functionality has been applied.
  </para>
  <para>
    The source file is structured as a single outer class,
    <literal>c</literal>. Within it, a number of constants and inner
    classes together model an environment for sending and receiving data
    from a kdb+ process. This section explores the fundamentals of the
    class to provide context and understanding of practical use-cases
    for the API.
  </para>
  <section xml:id="connection-and-interface-logic">
    <title>Connection and interface logic</title>
    <para>
      The highly-recommended means of connecting to a kdb+ process using
      the API is through instantiation of the <literal>c</literal>
      object itself. Three constructors provide for this purpose:
    </para>
    <programlisting language="java">
public c(String host,int port,String usernamepassword) 
public c(String host,int port,String usernamepassword,boolean useTLS)
public c(String host,int port)
</programlisting>
    <para>
      These constructors are straightforward to use. The host and port
      specify a socket-object connection, with the username/password
      string serialized and passed to the remote instance for
      authorization. The core logic is the same for all; the
      host/port-only constructor attempts to retrieve the user string
      from the Java properties, and the constructor with the
      <literal>useTLS</literal> boolean will, when flagged true, attempt
      to use an SSL socket instead of an ordinary socket.
    </para>
    <para>
      It is also possible to set up the object to accept incoming
      connections from kdb+ processes rather than just making them.
      There are two constructors which, when passed a server socket
      reference, will allow a q session to establish a handle against
      the <literal>c</literal> object:
    </para>
    <programlisting language="java">
public c(ServerSocket s)
public c(ServerSocket s,IAuthenticate a)
</programlisting>
    <para>
      <literal>IAuthenticate</literal> is an interface within the
      <literal>c</literal> class that can be implemented to emulate kdb+
      server-side authentication, allowing the establishment of
      authentication rules similar to that which might be done through
      the kdb+ function
      <link xlink:href="/ref/dotz/#zpw-validate-user">.z.pw</link>.
    </para>
    <para>
      Both of these constructor families represent two
      <quote>modes</quote> in which the <literal>c</literal> object can
      be instantiated. The first, and ultimately most widely used, is
      for making connections to kdb+ processes, which naturally would be
      used for queries, subscriptions and any task that requires the
      reception of or sending of data to said processes. The second,
      which sees Java act as the server, would see utility in management
      and aggregation of kdb+ clients, perhaps as a data sink or an
      intermediary interface for another technology.
    </para>
    <para>
      Interactions between Java and kdb+ through these connections are
      largely handled by what might be called the <quote>k</quote>
      family of methods in the <literal>c</literal> class. There are
      thirteen combined methods and overloads that fall under this
      group. They can be divided roughly into four groups:
    </para>
  </section>
  <section xml:id="synchronous-query-methods">
    <title>Synchronous query methods</title>
    <programlisting language="java">
public Object k(String expr)
public Object k(String s,Object x)
public Object k(String s,Object x,Object y)
public void k(String s,Object x,Object y,Object z)
public synchronized Object k(Object x)
</programlisting>
    <para>
      These methods are responsible for handling synchronous queries to
      a kdb+ process. The String parameter will represent either the
      entire q expression or the function name; in the case of the
      latter, the Object parameters may be used to pass values into that
      function. In all instances, the String/Object combinations are
      merged into a single object to be passed to the synchronized
      <literal>k(Object)</literal> method.
    </para>
  </section>
  <section xml:id="asynchronous-query-methods">
    <title>Asynchronous query methods</title>
    <programlisting language="java">
public void ks(String expr)
public void ks(String s,Object x)
public void ks(String s,Object x,Object y)
public void ks(String s,Object x,Object y,Object z)
public void ks(Object obj)
</programlisting>
    <para>
      These methods are responsible for handling asynchronous queries to
      a kdb+ process. They operate logically in a similar manner to the
      synchronous query method, with the exception that they are, of
      course, void methods in that they neither wait for nor return any
      response from the process.
    </para>
  </section>
  <section xml:id="incoming-message-method">
    <title>Incoming message method</title>
    <programlisting language="java">
public Object k()
</programlisting>
    <para>
      This method waits on the class input stream and will deserialize
      the next incoming kdb+ message. It is used by the
      <literal>c</literal> synchronous methods in order to capture and
      return response objects, and is also used in server-oriented
      applications in order to capture incoming messages from client
      processes.
    </para>
  </section>
  <section xml:id="response-message-methods">
    <title>Response message methods</title>
    <programlisting language="java">
public void kr(Object obj)
public void ke(String text)
</programlisting>
    <para>
      These methods are typically used in server-oriented applications
      to serialize and write response messages to the class output
      stream. <literal>kr(Object)</literal> will act much like any
      synchronous response, while <literal>ke(String)</literal> will
      format and output an error message.
    </para>
    <para>
      The use of these constructors and methods will be treated in more
      practical detail through the use-case examples below.
    </para>
  </section>
</section>
<section xml:id="models-and-type-mapping">
  <title>Models and type mapping</title>
  <para>
    The majority of q data types are represented in the API through
    mapping to standard Java objects. This is best seen in the method
    <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L709"><literal>c.r()</literal></link>,
    which reads bytes from an incoming message and converts those bytes
    into representative Java types.
  </para>
  <para>
    A
    <link xlink:href="/interfaces/java-client-for-q/#type-mapping">full
    list of Java type mappings</link> is on code.kx.com.
  </para>
  <section xml:id="basic-types">
    <title>Basic types</title>
    <para>
      The method <literal>c.r()</literal> deserializes a stream of bytes
      within a certain range to point to further methods which return
      the appropriate typed object. These are largely self-explanatory,
      such as booleans and integer primitives mapping directly to one
      another, or q UUIDs mapping to <literal>java.util.UUID</literal>.
      There are some types with caveats, however:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          The kdb+ float type (9) corresponds to
          <literal>java.lang.Double</literal> and
          <emphasis>not</emphasis> <literal>java.lang.Float</literal>,
          which corresponds to the kdb+ real type (8).
        </para>
      </listitem>
      <listitem>
        <para>
          Java strings map to the kdb+ symbol type (11). In terms of
          reading or passing in data, this means that passing
          <literal>&quot;String&quot;</literal> from Java to kdb would
          result in <literal>`String</literal>. Conversely, passing
          <literal>&quot;String&quot;</literal> (type 10 list) from kdb
          to Java would result in a six-index character array.
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section xml:id="time-based-types">
    <title>Time-based types</title>
    <para>
      Of particular interest is how the mapping handles temporal types,
      of which there are eight:
    </para>
    <informaltable>
      <tgroup cols="4">
        <colspec colwidth="25*" align="left" />
        <colspec colwidth="14*" align="left" />
        <colspec colwidth="39*" align="left" />
        <colspec colwidth="21*" align="left" />
        <thead>
          <row>
            <entry>
              q type
            </entry>
            <entry>
              id
            </entry>
            <entry>
              Java type
            </entry>
            <entry>
              note
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              datetime
            </entry>
            <entry>
              15
            </entry>
            <entry>
              <literal>java.util.Date</literal>
            </entry>
            <entry>
              This Java class stores times as milliseconds passed since
              the Unix epoch. Therefore, like the q datetime, it can
              represent time information accurate to the millisecond.
              (This despite the default output format of the class).
            </entry>
          </row>
          <row>
            <entry>
              date
            </entry>
            <entry>
              14
            </entry>
            <entry>
              java.sql.Date
            </entry>
            <entry>
              While this Java class extends the
              <literal>java.util</literal> date object it is used
              specifically for the date type as it restricts usage and
              output of time data.
            </entry>
          </row>
          <row>
            <entry>
              time
            </entry>
            <entry>
              19
            </entry>
            <entry>
              <literal>java.sql.Time</literal>
            </entry>
            <entry>
              This also extends <literal>java.util.Date</literal>,
              restricting usage and output of date data this time.
            </entry>
          </row>
          <row>
            <entry>
              timestamp
            </entry>
            <entry>
              12
            </entry>
            <entry>
              <literal>java.sql.Timestamp</literal>
            </entry>
            <entry>
              This comes yet again from the base date class, extended
              this time to include nanoseconds storage (which is done
              separately from the underlying date object, which only has
              millisecond accuracy). This makes it directly compatible
              with the q timestamp type.
            </entry>
          </row>
          <row>
            <entry>
              month
            </entry>
            <entry>
              13
            </entry>
            <entry>
              inner class
              <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L300"><literal>c.Month</literal></link>
            </entry>
            <entry>
            </entry>
          </row>
          <row>
            <entry>
              timespan
            </entry>
            <entry>
              16
            </entry>
            <entry>
              inner class
              <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L376"><literal>c.Timespan</literal></link>
            </entry>
            <entry>
            </entry>
          </row>
          <row>
            <entry>
              minute
            </entry>
            <entry>
              17
            </entry>
            <entry>
              inner class
              <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L326"><literal>c.Minute</literal></link>
            </entry>
            <entry>
            </entry>
          </row>
          <row>
            <entry>
              second
            </entry>
            <entry>
              18
            </entry>
            <entry>
              inner class
              <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L351"><literal>c.Second</literal></link>
            </entry>
            <entry>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      When manipulating date, time and datetime data from kdb+ it is
      important to note that while <literal>java.sql.Date</literal> and
      <literal>Time</literal> extend <literal>java.util.Date</literal>,
      and can be assigned to a <literal>java.util</literal> reference,
      that many of the methods from the original date class are
      overridden in these to throw exceptions if invoked. For example,
      in order to create a single date object for two separate SQL Date
      and Time objects, a <literal>java.util.Date</literal> object
      should be instantiated by adding the <literal>getTime()</literal>
      values from both SQL objects:
    </para>
    <programlisting language="java">
//Date value = datetime - time
java.sql.Date sqlDate = (java.sql.Date)qconn.k(&quot;.z.d&quot;); 
// Time value - datetime - date
java.sql.Time sqlTime = (java.sql.Time)qconn.k(&quot;.z.t&quot;); 
java.util.Date utilDate= new java.util.Date(sqlDate.getTime()+sqlTime.getTime());
</programlisting>
    <para>
      The four time types represented by inner classes are somewhat less
      prevalent than those modeled by Date and its subclasses. These
      classes exist as comparable models due to a lack of a clear
      representative counterpart in the standard Java library, although
      their modeling is for the large part fairly simple and the values
      can be easily implemented or extracted.
    </para>
  </section>
  <section xml:id="dictionaries-and-tables">
    <title>Dictionaries and tables</title>
    <para>
      Kdb+ dictionaries (type 99) and tables (type 98) are represented
      by the internal classes Dict and Flip respectively. The makeup of
      these models is simple but effective, and useful in determining
      how best to manipulate them.
    </para>
    <para>
      <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L427">The
      Dict class</link> consists of two public
      <literal>java.lang.Object</literal> fields (<literal>x</literal>
      for keys, <literal>y</literal> for values) and a basic
      constructor, which allows any of the represented data types to be
      used. However, while from a Java perspective any object could be
      passed to the constructor, dictionaries in q are always structured
      as two lists. This means that if the object is being created to
      pass to a q session directly, the Object fields in a Dict object
      should be assigned arrays of a given representative type, as
      passing in an atomic object will result in an error.
    </para>
    <para>
      For example, the first of the following dictionary instantiation
      is legal with regards to the Java object, but because the pairs
      being passed in are atomic, it would signal a type error in q.
      Instead, the second example should be used, and can be seen as
      mirroring the practice of enlisting single values in q:
    </para>
    <programlisting language="java">
new c.Dict(&quot;Key&quot;,&quot;Value&quot;); // not q-compatible
new c.Dict(new String[] {&quot;Key&quot;}, new String[] {&quot;Value&quot;}); // q-compatible
</programlisting>
    <para>
      As the logical extension of that, in order to represent a list as
      a single key or pair, multi-dimensional arrays should be used:
    </para>
    <programlisting language="java">
new c.Dict(new String[] {&quot;Key&quot;}, new String[][] {{&quot;Value1&quot;,&quot;Value2&quot;,&quot;Value3&quot;}});
</programlisting>
    <para>
      <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L440">Flip
      (table) objects</link> consist of a String array for columns, an
      Object array for values, a constructor and a method for returning
      the Object array for a given column. The constructor takes a
      dictionary as its parameter, which is useful for the conversion of
      one to the other should the dictionary in question consist of
      single symbol keys. Of course, with the fields of the class being
      public, the columns and values can be assigned manually.
    </para>
    <para>
      Keyed tables in q are dictionaries in terms of type, and therefore
      will be represented as a Dict object in Java. The method
      <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L1396"><literal>td(Object)</literal></link>
      will create a Flip object from a keyed table Dict, but will remove
      its keyed nature in the process.
    </para>
  </section>
  <section xml:id="guid">
    <title>GUID</title>
    <para>
      The globally unique identifier (GUID) type was introduced into
      kdb+ with version 3.0 for the purpose of storing arbitrary 16-byte
      values, such as transaction IDs. Storing such values in this form
      allows for savings in tasks such as memory and storage usage, as
      well as improved performance in certain operations such as table
      lookups when compared with standard types such as Strings.
    </para>
    <para>
      Java has its own unique identifier type:
      <literal>java.util.UUID</literal> (universally unique identifier).
      In the API the kdb+ GUID type maps directly to this object through
      the extraction and provision of its most and least significant
      long values. Otherwise, the only high-level difference in how this
      type can be used when compared to other types handled by the API
      is that a <literal>RuntimeException</literal> will be thrown if an
      attempt is made to serialize and pass a UUID object to a kdb+
      instance with a version lower than 3.0.
    </para>
    <para>
      More information on these identifier types can be found in the
      <link xlink:href="/ref/datatypes/#guid">Kx documentation</link> as
      well as the
      <link xlink:href="https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html">core
      Java documentation</link>.
    </para>
  </section>
  <section xml:id="null-types">
    <title>Null types</title>
    <para>
      Definitions for q null type representations in Java are held in
      the static Object array <literal>NULL</literal>, with index
      positions representing the q type.
    </para>
    <programlisting language="java">
public static Object[] NULL={
    null,
    new Boolean(false),
    new UUID(0,0),
    null,
    new Byte((byte)0),
    new Short(Short.MIN_VALUE),
    new Integer(ni),
    new Long(nj),
    new Float(nf),
    new Double(nf),
    new Character(' '),
    &quot;&quot;,
    new Timestamp(nj),
    new Month(ni)
    ,new Date(nj),
    new java.util.Date(nj),
    new Timespan(nj),
    new Minute(ni),
    new Second(ni),
    new Time(nj)
};
</programlisting>
    <para>
      Of note are the integer types, as the null values for these are
      represented by the minimum possible value of each of the Java
      primitives. Shorts, for example, have a minimum value of -372768
      in Java, but a minimum value of -372767 in q. The extra negative
      value in Java can therefore be used to signal a null value to the
      q connection logic in the <literal>c</literal> class.
    </para>
    <para>
      Float and real nulls are both represented in Java by the
      <literal>java.lang.Double.NaN</literal> constant. Time values,
      essentially being longs under the bonnet, are represented by the
      same null value as longs in Java. Month, minute, second and
      timespan, each with custom model classes, use the same null value
      as ints.
    </para>
    <para>
      The method
      <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L1355"><literal>c.qn(Object)</literal></link>
      can assist with checking and identifying null value
      representations, as it will check both the
      <literal>Object</literal> type and value against the
      <literal>NULL</literal> list.
    </para>
    <para>
      It is worth noting that infinity types are not explicitly mapped
      in Java, although kdb+ float and real infinities will correspond
      with the infinity constants in <literal>java.lang.Double</literal>
      and <literal>java.lang.Float</literal> respectively.
    </para>
  </section>
  <section xml:id="exceptions">
    <title>Exceptions</title>
    <para>
      <link xlink:href="https://github.com/KxSystems/javakdb/blob/master/src/kx/c.java#L457"><literal>KException</literal></link>
      is the single custom exception defined and thrown by the API. It
      is fairly safe to assume that a thrown
      <literal>KException</literal> denotes a q error signal, which will
      be included in the exception message when thrown.
    </para>
    <para>
      Other common exceptions thrown in the API logic include:
    </para>
    <variablelist>
      <varlistentry>
        <term>
          IOException
        </term>
        <listitem>
          <para>
            Denotes issues with connecting to the kdb+ process. It is
            also thrown by <literal>c.java</literal> itself for such
            issues as authentication.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          RuntimeException
        </term>
        <listitem>
          <para>
            Thrown when certain type implementations are attempted on
            kdb+ versions prior to their introduction (such as the GUIDs
            prior to kdb+ 3.0)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          UnsupportedEncodingException
        </term>
        <listitem>
          <para>
            It is possible, through the method
            <literal>setEncoding</literal>, to specify character
            encoding different to the default
            (<literal>ISO-859-1</literal>). This exception will be
            thrown commonly if the default is changed to a charset
            format not implemented on the target Java platform.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
</section>
<section xml:id="practical-use-case-examples">
  <title>Practical use-case examples</title>
  <para>
    The examples that follow consist of common practical tasks that a
    Java developer might be expected to carry out when interfacing with
    kdb+. The inline examples take the form of extracted sections of key
    logic and output, and are available as example classes from the
    <link xlink:href="https://github.com/KxSystems/javakdb/tree/master/src/kx/examples">KxSystems/javakdb</link>
    repository for use as starting points or templates.
  </para>
  <para>
    These examples assume, at minimum, a standard installation of 32-bit
    kdb+ on the local system, and a suitable Java development
    environment.
  </para>
</section>
<section xml:id="connecting-to-a-kdb-process">
  <title>Connecting to a kdb+ process</title>
  <section xml:id="starting-a-local-q-server">
    <title>Starting a local q server</title>
    <para>
      During development, it can be helpful to start a basic q server to
      which a Java process can connect. This requires the opening of a
      port, for which there are two basic methods:
    </para>
    <para>
      Example: Starting q with <literal>–p</literal> parameter
    </para>
    <programlisting language="bash">
$ q -p 10000
</programlisting>
    <programlisting language="r script">
q)\p // command to show the port that q is listening on
10000i
</programlisting>
    <para>
      Example: Using the <literal>\p</literal> system command
    </para>
    <programlisting language="bash">
$ q
</programlisting>
    <programlisting language="r script">
q)\p 10000 // set the listening port to 10000
q)\p
10000i
</programlisting>
    <para>
      To close the port, it should be set to its default value of 0 i.e.
      <literal>\p 0</literal>.
    </para>
    <para>
      Setting up a q session in this manner will allow other processes
      to open handles to it on the specified port. The remainder of the
      examples in this paper assume an opened q session listening on
      port 10000, with no further configuration unless otherwise
      specified.
    </para>
  </section>
  <section xml:id="opening-a-socket-connection">
    <title>Opening a socket connection</title>
    <para>
      As discussed in the previous section, the <literal>c</literal>
      class establishes connections via its constructors.
    </para>
    <para>
      For connecting to a listening q process, one useful mechanism
      might be to create a factory class with a method that returns a
      connected <literal>c</literal> object based on what is passed to
      it. This way, any number of credential combinations can be set
      whilst allowing the creation of multiple connections, say for
      reconnection purposes:
    </para>
    <para>
      Example: <literal>QConnectionFactory.java</literal>
    </para>
    <programlisting language="java">
public QConnectionFactory(String host, int port, 
    String username, String password, boolean useTLS) {
  this.host=host;
  this.port=port;
  this.username=username;
  this.password=password;
  this.useTLS=useTLS;
}

//[…]

public c getQConnection() throws KException, IOException {
  return new c(host,port,username+&quot;:&quot;+password,useTLS);
}
</programlisting>
    <para>
      These constructors will always return a <literal>c</literal>
      object connected to the target session, and failure to do so will
      result in a thrown exception; <literal>IOException</literal> will
      denote the port not being open or available, and a
      <literal>KException</literal> will denote something wrong with the
      q process itself (such as <literal>'access</literal> for incorrect
      or incomplete credentials).
    </para>
    <para>
      For the remaining examples, connections will be made using a
      custom <literal>QConnectionFactory</literal> object returned from
      a static method <literal>getDefault()</literal>, which will
      instantiate the object with the host <literal>localhost</literal>
      and the port 10000:
    </para>
    <para>
      Example: <literal>QConnectionFactory.java</literal>
    </para>
    <programlisting language="java">
public static QConnectionFactory getDefault() {
  return new QConnectionFactory(&quot;localhost&quot;, 10000);
}
</programlisting>
    <para>
      Connection objects created using this will be given the variable
      name <literal>qConnection</literal> unless otherwise stated.
    </para>
  </section>
  <section xml:id="running-queries-using-k-methods">
    <title>Running queries using k methods</title>
    <para>
      Queries can be made using the <quote>k</quote> family of methods
      in the <literal>c</literal> class. For synchronous queries, that
      might be used to retrieve data (or, more generally, to halt
      execution of the java process until a response is received), the k
      methods with parameter combinations of strings and objects might
      be used. For asynchronous queries, as might be used in a
      feed-handler process to push data to a tickerplant, the
      <literal>ks</literal> methods would be used.
    </para>
    <para>
      The methods <literal>k()</literal>, <literal>kr()</literal> and
      <literal>ke()</literal> would not see explicit use in the querying
      of a server q process, but are more significant when the Java
      process acts as the server, as will be touched upon below.
    </para>
    <para>
      The following examples demonstrate some of the means by which
      these synchronous and asynchronous queries may be called:
    </para>
    <para>
      Example: <literal>SimpleQueryExamples.java</literal>
    </para>
    <programlisting language="java">
//Object for storing the results of these queries
Object result = null;

//Basic synchronous q expression
result = qConnection.k(&quot;{x+y}\[4;3\]&quot;);
System.out.println(result.toString());

//parameterised synchronous query
result = qConnection.k(&quot;{x+y}&quot;,4,3); //Note autoboxing!
System.out.println(result.toString());

//asynchronous assignment of function
qConnection.ks(&quot;jFunc:{x-y+z}&quot;);

//synchronous calling of that function
result = qConnection.k(&quot;jFunc&quot;,10,4,3);
System.out.println(result);

//asynchronous error - note no exception can be returned, so be careful!
qConnection.ks(&quot;{x+y}\[4;3;2\]&quot;);

//Always close resources\!
qConnection.close(); 
</programlisting>
  </section>
</section>
<section xml:id="extracting-data-from-returned-objects">
  <title>Extracting data from returned objects</title>
  <section xml:id="note-on-internal-variables-and-casting">
    <title>Note on internal variables and casting</title>
    <para>
      The relationship between the kdb+ types and their Java
      counterparts has been discussed in the previous section. From a
      practical perspective, it is important to note that almost all
      objects and fields that might return from a given synchronous
      query will be of type Object, and will therefore more often than
      not require casting in order to be manipulated properly. Care must
      be taken, therefore, to ensure that the types that can be returned
      from a given query are known and handled appropriately so as to
      avoid unwanted exceptions.
    </para>
    <para>
      The exception to this might be the column names of a
      <literal>flip</literal> object (once cast itself) held in the
      field <literal>flip.x</literal>. This field is already typed as
      <literal>String[]</literal>, as column names must always be
      symbols in q.
    </para>
    <para>
      Kdb+ types that map to primitives (such as int) can be passed in
      Java to a <literal>k</literal> method as a primitive thanks to
      <link xlink:href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">autoboxing</link>,
      but will always be returned as the corresponding wrapper object
      (such as Integer).
    </para>
  </section>
  <section xml:id="extracting-atoms-from-a-list">
    <title>Extracting atoms from a list</title>
    <para>
      Lists will always be returned as an array of the given list type,
      or as <literal>Object[]</literal> if the list is generic.
      Extraction of atomic values from a list, therefore, is as simple
      as casting the return object to the appropriate array type and
      accessing the desired index:
    </para>
    <para>
      Example: <literal>ExtractionExamples.java</literal>
    </para>
    <programlisting language="java">
//Get a list from the q session
Object result = qConnection.k(&quot;(1 2 3 4)&quot;);

//Cast the returned Object into long[], and retrieve the desired result.
long[] castList = ((long[]) result);
long extractedAtom = castList[0];
System.out.println(extractedAtom);
</programlisting>
    <para>
      If the type of list is unknown, the method
      <literal>c.t(Object)</literal> can be used to derive the q type of
      the object, and theoretically could be useful in further casting
      efforts.
    </para>
  </section>
  <section xml:id="extracting-lists-from-a-nested-list">
    <title>Extracting lists from a nested list</title>
    <para>
      Accessing a list from a nested list is similar to accessing a
      value from any list. Here there are two casts required: a cast to
      <literal>Object[]</literal> for the parent list and then again to
      the appropriate typed array for the extracted list:
    </para>
    <para>
      Example: <literal>ExtractionExamples.java</literal>
    </para>
    <programlisting language="java">
// Start by casting the returned Object into Object[]
Object[] resultArray = (Object[]) qConnection.k(&quot;((1 2 3 4); (1 2))&quot;);

//Iterate through the Object array
for (Object resultElement : resultArray) {

  //Retrieve each list and cast to appropriate type
  long[] elementArray = (long[]) resultElement;

  //Iterate through these arrays to access values.
  for(long elementAtom : elementArray) {
    System.out.println(elementAtom);
  }
}
</programlisting>
  </section>
  <section xml:id="working-with-dictionaries">
    <title>Working with dictionaries</title>
    <para>
      The Dict inner class is used for all returned objects of q type
      dictionary (and therefore, by extension, keyed tables). Key values
      are stored in the field <literal>Dict.x</literal>, and values in
      <literal>Dict.y</literal>, both of which will generally be
      castable as an array.
    </para>
    <para>
      Aside from matching the index positions of <literal>x</literal>
      and <literal>y</literal>, there is no intrinsic key-value pairing
      between the two, meaning that alteration of either of the array
      structures can compromise the key-value relationship. The
      following example illustrates operations that might be performed
      on a returned dictionary object:
    </para>
    <para>
      Example: <literal>ExtractionExamples.java</literal>
    </para>
    <programlisting language="java">
//Retrieve Dictionary
c.Dict dict = (c.Dict) qConnection.k(&quot;`a`b`c!((1 2 3);\&quot;Second\&quot;; (`x`y`z))&quot;);
//Retrieve keys from dictionary
String[] keys = (String[]) dict.x;
System.out.println(Arrays.toString(keys));
//Retrieve values
Object[] values = (Object[]) dict.y;
//These can then be worked with similarly to nested lists
long[] valuesLong = (long[]) values[0];
//[…]
</programlisting>
  </section>
  <section xml:id="working-with-tables">
    <title>Working with tables</title>
    <para>
      The inner class <literal>c.Flip</literal> used to represent tables
      operates in a similar manner to <literal>c.Dict</literal>. The
      primary difference, as previously mentioned, is that
      <literal>Flip.x</literal> is already typed as
      <literal>String[]</literal>, while <literal>Flip.y</literal> will
      still require casting. The following example shows how the data
      from a returned <literal>Flip</literal> object might be used to
      print the table to console:
    </para>
    <para>
      Example: <literal>ExtractionExamples.java</literal>
    </para>
    <programlisting language="java">
// (try to load trade.q first for this (create a table manually if not possible)
qConnection.ks(&quot;system \&quot;l trade.q\&quot;&quot;);
//Retrieve table
c.Flip flip = (c.Flip) qConnection.k(&quot;select from trade where sym = `a&quot;);

//Retrieve columns and data
String[] columnNames = flip.x;
Object[] columnData = flip.y;
//Extract row data into typed arrays
java.sql.Timestamp[] time = (java.sql.Timestamp[]) columnData[0];
String[] sym = (String[]) columnData[1];
double[] price = (double[]) columnData[2];
int[] size = (int[]) columnData[3];
int rows = time.length;

//Print the table now - columns first:
for (String columnName : columnNames)
{
  System.out.print(columnName + &quot;\t\t\t&quot;);
}
System.out.println(&quot;\n-----------------------------------------------------&quot;);
//Then rows:
for (int i = 0; i &lt; rows; i++)
{
  System.out.print(time[i]+&quot;\t&quot;+sym[i]+&quot;\t\t\t&quot;+price[i]+&quot;\t\t\t&quot;+size[i]+&quot;\n&quot;);
}
</programlisting>
  </section>
</section>
<section xml:id="creating-and-passing-data-objects">
  <title>Creating and passing data objects</title>
  <para>
    When passing objects to q via the <literal>c</literal> class, there
    is less emphasis on how a given object is created. Rather, such an
    operation is subject to the common pitfalls associated with passing
    values to a q expression; those of type and rank.
  </para>
  <para>
    The k family of methods, regardless of its return protocol, will
    take either the String of a q expression or the String of a q
    operator or function, complemented by Object parameters. Given the
    nature of q as an interpreted language, all of these are serialized
    and sent to the q session with little regard for logical
    correctness.
  </para>
  <para>
    It is important, therefore, that any expressions passed to a query
    method are syntactically accurate and refer to variables that
    actually exist in the target session. It is also important that any
    passed objects are mapped to a relevant q type, and function within
    the context that they are sent. <literal>KException</literal>
    messages to look out for while implementing these operations are
    <literal>'type</literal> and <literal>'rank</literal>, as these will
    generally denote basic type and rank issues respectively.
  </para>
  <section xml:id="creating-and-passing-a-simple-list">
    <title>Creating and passing a simple list</title>
    <para>
      The following method might be applied to all direct type mappings
      in the API; for simple lists (lists in which all elements are of
      the same type), it is enough to pass a Java array of the
      appropriate type.
    </para>
    <para>
      The following example invokes the q <literal>set</literal>
      function, which allows for the passing of a variable name as well
      as an object with which the variable might be set:
    </para>
    <para>
      Example: <literal>CreateAndSendExamples.java</literal>
    </para>
    <programlisting language="java">
//Create typed array
int[] simpleList = {10, 20, 30};
//Pass array to q using set function.
qConnection.k(&quot;set&quot;, &quot;simpleList&quot;, simpleList)
</programlisting>
    <section xml:id="creating-and-passing-a-mixed-list">
      <title>Creating and passing a mixed list</title>
      <para>
        Mixed lists should always be passed to kdb+ through an Object
        array, <literal>Object[]</literal>. This array may then hold any
        number of mapped types, including, if appropriate, other typed
        or Object arrays:
      </para>
      <para>
        Example: <literal>CreateAndSendExamples.java</literal>
      </para>
      <programlisting language="java">
//Create generic Object array.
Object[] mixedList = {new String[] {&quot;first&quot;, &quot;second&quot;}, new double[] {1.0, 2.0}};
//Pass to q in the same way as a simple list.
qConnection.k(&quot;set&quot;, &quot;mixedList&quot;, mixedList);
</programlisting>
    </section>
  </section>
  <section xml:id="creating-and-passing-dictionaries">
    <title>Creating and passing dictionaries</title>
    <para>
      <literal>c.Dict</literal> objects are instantiated by setting its
      <literal>x</literal> and <literal>y</literal> objects in the
      constructor, and these objects should always be arrays. Once
      created, the Dict can be passed to kdb+ like any other object:
    </para>
    <para>
      Example: <literal>CreateAndSendExamples.java</literal>
    </para>
    <programlisting language="java">
//Create keys and values
Object[] keys = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
int[] values = {100, 200, 300};
//Set in dict constructor
c.Dict dict = new c.Dict(keys, values);
//Set in q session
qConnection.k(&quot;set&quot;,&quot;dict&quot;,dict);
</programlisting>
  </section>
  <section xml:id="creating-and-passing-tables">
    <title>Creating and passing tables</title>
    <para>
      <literal>c.Flip</literal> objects are created slightly
      differently; it is best to instantiate these by passing a
      <literal>c.Dict</literal> object into the constructor. This is
      because tables are essentially collections of dictionaries in
      kdb+, and therefore using this constructor helps ensure that the
      Flip object is set up correctly.
    </para>
    <para>
      It is worth noting that for this method to work correctly, the
      passed Dict object must use String keys, as these will map into
      the Flip object’s typed <literal>String[]</literal> columns:
    </para>
    <para>
      Example: <literal>CreateAndSendExamples.java</literal>
    </para>
    <programlisting language="java">
//Create rows and columns
int[] values = {1, 2, 3};
Object[] data = new Object[] {values};
String[] columnNames = new String[] {&quot;column&quot;};
//Wrap values in dictionary
c.Dict dict = new c.Dict(columnNames, data);
//Create table using dict
c.Flip table = new c.Flip(dict);
//Send to q using 'insert' method
qConnection.ks(&quot;insert&quot;, &quot;t1&quot;, table);
</programlisting>
  </section>
  <section xml:id="creating-and-passing-guid-objects">
    <title>Creating and passing GUID objects</title>
    <para>
      Globally universal identifier objects are represented in Java by
      <literal>java.util.UUID</literal> objects, and are passed to kdb+
      in an identical manner as other basic types. The Java object has a
      useful static method for generating random identifiers, which
      further streamlines this process and can see utility in some use
      cases where only a certain number of arbitrary identifiers are
      required:
    </para>
    <para>
      Example: <literal>CreateAndSendExamples.java</literal>
    </para>
    <programlisting language="java">
//Generate random UUID object
java.util.UUID uuid = java.util.UUID.randomUUID();
System.out.println(uuid.toString());

//Pass object to q using set function
qConnection.k(&quot;set&quot;,&quot;randomGUID&quot;,uuidj);
System.out.println(qConnection.k(&quot;randomGUID&quot;).toString());
</programlisting>
    <para>
      Of course, it should be remembered that kdb+ version 3.0 or higher
      is required to work with GUIDs, and running the above code
      connected to an older version will cause a
      <literal>RuntimeException</literal> to be thrown.
    </para>
  </section>
</section>
<section xml:id="reconnecting-to-a-q-process-automatically">
  <title>Reconnecting to a q process automatically</title>
  <para>
    Requirements will often dictate that while q processes will need to
    be bounced (such as for End-of-Day processing), that a Java process
    will need to be able to handle loss and reacquisition of said
    processes without being restarted itself. A simple example might be
    a graphical user interface, where the forced shutdown of the entire
    application due to a dropped connection, or the lack of ability to
    reconnect, would be very poor design indeed.
  </para>
  <para>
    Use of patterns such as factories can help with the task of setting
    up a reconnection mechanism, as it allows for the simple creation of
    a preconfigured object. For <literal>c</literal> Objects, given that
    they connect on instantiation, means that a connection can be
    re-established simply by calling the relevant factory method.
  </para>
  <para>
    In order to handle longer periods of potential downtime, either
    loops or recursion should be used. The danger with recursive
    methodology here is that, given an extended without a timeout
    limitation, there is a risk of overflowing the method-call stack, as
    each failed attempt will invoke a new method onto the stack.
  </para>
  <para>
    For mechanisms that may need to wait indefinitely, it might be
    considered safer to use an indefinite while-loop that makes use of
    catch blocks, continue and break statements. This averts the danger
    of <literal>StackOverflowError</literal> occurring and is easily
    modified to implement a maximum number of tries:
  </para>
  <para>
    Example: <literal>ReconnectionExample.java</literal>
  </para>
  <programlisting language="java">
//initiate reconnect loop (possibly within a catch block).
while (true) {
  try {
    System.err.println(&quot;Connection failed - retrying..&quot;);
    //Wait a bit before trying to reconnect
    Thread.sleep(5000);
    qConnection = qConnFactory.getQConnection();
    System.out.println(&quot;Connection re-established! Resuming..&quot;);
    //Exit loop
    break;
  } catch (IOException | KException e1) {
    //resume loop if it fails
    continue;
  }
  …
}
</programlisting>
</section>
<section xml:id="kdb-tickerplant-overview">
  <title>Kdb+ tickerplant overview</title>
  <para>
    A kdb+ tickerplant is a q process specifically designed to handle
    incoming high-frequency data feeds from publishing process. Its
    primary responsibility is the management of subscription requests
    and the fast publication of data to subscribers. The following
    diagram illustrates a simple dataflow of a potential kdb+ tick
    system:
  </para>
  <figure>
    <title>Simple dataflow of a potential kdb+ tick system</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="media/image2.png" />
      </imageobject>
      <textobject><phrase>Simple dataflow of a potential kdb+ tick
      system</phrase></textobject>
    </mediaobject>
  </figure>
  <para>
    <i class="fa fa-hand-o-right"></i>
    <link xlink:href="/wp/building_real_time_tick_subscribers.pdf"><emphasis>Building
    Real-time Tick Subscribers</emphasis></link> regarding the above
    vanilla setup
  </para>
  <para>
    Of interest in this whitepaper are the Java publisher and subscriber
    processes. As the kdb+ tick system is very widely used, both of
    these kinds of processes are highly likely to come up in development
    tasks involving kdb+ interfacing.
  </para>
  <section xml:id="test-tickerplant-and-feedhandler-setup">
    <title>Test tickerplant and feedhandler setup</title>
    <para>
      To facilitate the testing of Java subscriber processes we can
      implement example q processes freely available in the Kx
      repository. Simulation of a tickerplant can be achieved with
      <link xlink:href="https://github.com/KxSystems/kdb-tick/blob/master/tick.q"><literal>tick.q</literal></link>;
      Trade data, using the trade schema defined in
      <literal>sym.q</literal>, can then be published to this
      tickerplant using the definition for the file
      <literal>feed.q</literal> given here:
    </para>
    <programlisting language="r script">
// q feed.q / with a default port of 5010 and default timer of 1000
// q feed.q -port 10000 / with a default timer of 1000
// q feed.q -port 10000 -t 2000

tph:hopen $[0=count .z.x;5010;&quot;J&quot;$first .Q.opt\[.z.x]`port]
if[not system&quot;t&quot;;system&quot;t 1000&quot;]

publishTradeToTickerPlant:{
  nRows:first 1?1+til 3;
  tph(&quot;.u.upd&quot;;`trade;(nRows#.z.N;nRows?`IBM`FB`GS`JPM;nRows?150.35;nRows?1000));
  }

.z.ts:{
  publishTradeToTickerPlant[];
  }
</programlisting>
    <para>
      The tickerplant and feed handlers can then be started by executing
      the following commands consecutively:
    </para>
    <programlisting language="bash">
$ q tick.q sym -t 2000
$ q feed.q
</programlisting>
    <para>
      Once the feedhandler is publishing to the tickerplant, processes
      can connect to it in order either to publish or subscribe to it.
    </para>
    <para>
      It should be noted that in this example and below we are using a
      Java process to subscribe to a tickerplant being fed directly by a
      simulated feed. While we are doing this here in order to
      facilitate a simple example setup, in production this is not
      usually encouraged. Processes such as Java subscribers would
      generally connect to derivative kdb+ processes such as chained
      tickerplants (as in the above diagram), for which standard
      publishing and subscription logic should be the same as that
      covered here.
    </para>
  </section>
</section>
<section xml:id="tickerplant-subscription">
  <title>Tickerplant subscription</title>
  <section xml:id="extracting-the-table-schema">
    <title>Extracting the table schema</title>
    <para>
      Typical subscriber processes are required to make an initial
      subscription request to the tickerplant in order to receive data.
      See the <link xlink:href="/cookbook/publish-subscribe">publish and
      subscribe</link> cookbook article for details. This request
      involves calling the <literal>.u.sub</literal> function with two
      parameters. The first parameter is the table name and the second
      is a list of symbols for subscription. (Specifying a backtick in
      any of the parameters means all tables and/or all symbols).
    </para>
    <para>
      Example: <literal>TickSubscriberExample.java</literal>
    </para>
    <programlisting language="java">
// Run sub function and store result
Object[] response = (Object[]) qConnection.k(&quot;.u.sub[`trade;`]&quot;);
</programlisting>
    <para>
      If the <literal>.u.sub</literal> function is called synchronously,
      the tickerplant will return the table schema. If subscribing to
      one table, the returned object will be a generic Object array,
      with the table name in <literal>object[0]</literal> and a
      <literal>c.Flip</literal> representation of the schema in
      <literal>object[1]</literal>:
    </para>
    <para>
      Example: <literal>TickSubscriberExample.java</literal>
    </para>
    <programlisting language="java">
// first index is table name
System.out.println(&quot;table name: &quot; + response[0]);

// second index is flip object
c.Flip table = (c.Flip) response[1];

// Retrieve column names
String[] columnNames = table.x;
for (int i = 0; i &lt; columnNames.length; i++) {
  System.out.printf(&quot;Column %d is named %s\n&quot;, i, columnNames[i]);
}
</programlisting>
    <para>
      If more than one table is being subscribed to, the returned object
      will be an Object array consisting of the above object arrays;
      therefore, in order to retrieve each individual Flip object, this
      should be iterated against:
    </para>
    <para>
      Example: <literal>TickSubscriberExample.java</literal>
    </para>
    <programlisting language="java">
// Run sub function and store result
Object[] response = (Object[]) qConnection.k(&quot;.u.sub[`;`]&quot;);

// iterate through Object array
for (Object tableObjectElement : response) {

  // From here, it is similar to the one-table schema extraction
  Object[] tableData = (Object[]) tableObjectElement;
  System.out.println(&quot;table name: &quot; + tableData[0]);
  c.Flip table = (c.Flip) tableData[1];
  String[] columnNames = table.x;
  for (int i = 0; i &lt; columnNames.length; i++) {
    System.out.printf(&quot;Column %d is named %s\n&quot;, i, columnNames[i]);
  }
}
</programlisting>
  </section>
  <section xml:id="subscribing-to-a-tickerplant-data-feed">
    <title>Subscribing to a tickerplant data feed</title>
    <para>
      Upon calling <literal>.u.sub</literal> and retrieving the schema,
      the tickerplant process will start to publish data to the Java
      process. The data it sends can be retrieved through the
      parameter-free <literal>k()</literal> method, which will wait for
      a response and return an Object (a <literal>c.Flip</literal> of
      the passed data) on publication:
    </para>
    <para>
      Example: <literal>TickSubscriberExample.java</literal>
    </para>
    <programlisting language="java">
while (true) {

  //wait on k()
  Object response = qConnection.k();

  if(response != null) {
    Object[] data = (Object[]) response;

    //Slightly different.. table is in data[2]\!
    c.Flip table = (c.Flip) data[2];
    //[…]
  }
}
</programlisting>
    <para>
      With the data in this form, it can be manipulated in a number of
      meaningful ways. To iterate through the columns,
      <literal>c.n</literal> can be called on individual
      <literal>flip.y</literal> columns in order to provide a row count:
    </para>
    <para>
      Example: <literal>TickSubscriberExample.java</literal>
    </para>
    <programlisting language="java">
String[] columnNames = table.x;
Object[] columnData = table.y;

//Get row count for looping
int rowCount = c.n(columnData[0]);

//Print out the table!
System.out.printf(&quot;%s\t\t\t%s\t%s\t%s\n&quot;, 
    columnNames[0], columnNames[1], columnNames[2], columnNames[3]);
System.out.println(&quot;--------------------------------------------&quot;);
for (int i = 0; i &lt; rowCount; i++) {

  //[Printing logic]

}
</programlisting>
    <para>
      This mechanism might be then enveloped in an indefinite loop, such
      as a <literal>while(true)</literal> loop. Each iteration waits on
      the <literal>k()</literal> method returning published data, which
      will continue until one of the contributing processes fails (at
      which point an exception is caught and handled appropriately).
    </para>
  </section>
</section>
<section xml:id="tickerplant-publishing">
  <title>Tickerplant publishing</title>
  <para>
    Publishing data to a tickerplant is almost always a necessity for a
    kdb+ feed-handler process. Java, as a common language of choice for
    third-party API development (e.g. Reuters, Bloomberg, MarkIT), is a
    popular language for feedhandler development, within which
    <literal>c.java</literal> is used to handle the asynchronous
    invocation of a publishing function.
  </para>
  <section xml:id="publishing-rows">
    <title>Publishing rows</title>
    <para>
      In general, publishing values to a tickerplant will require an
      asynchronous query much like the following:
    </para>
    <programlisting language="java">
qConnection.ks(&quot;.u.upd&quot;, &quot;trade&quot;, data); //Where data is an Object[]
</programlisting>
    <para>
      The parameters for this can be defined as follows:
    </para>
    <variablelist>
      <varlistentry>
        <term>
          The update function name (<literal>.u.upd</literal>)
        </term>
        <listitem>
          <para>
            This is the function executed on the tickerplant which
            enables the data insertion. As per the norm with this API,
            this is passed as a string.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          Table name
        </term>
        <listitem>
          <para>
            A String representation of the name of the table that
            receives the data.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          Data
        </term>
        <listitem>
          <para>
            An Object that will form the row(s) to be appended to the
            table. This parameter is typically passed as an object
            array, each index representing a table column.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      In order to publish a single row to a tickerplant, typed arrays
      consisting of single values might be instantiated. These are then
      encapsulated in an Object array and passed to the
      <literal>ks</literal> method:
    </para>
    <para>
      Example: <literal>TickPublisherExamples.java</literal>
    </para>
    <programlisting language="java">
//Create typed arrays for holding data
String[] sym = new String[] {&quot;IBM&quot;};
double[] bid = new double[] {100.25};
double[] ask = new double[] {100.26};
int[] bSize = new int[]{1000};
int[] aSize = new int[]{1000};
//Create Object[] for holding typed arrays
Object[] data = new Object[] {sym, bid, ask, bSize, aSize};
//Call .u.upd asynchronously
qConnection.ks(&quot;.u.upd&quot;, &quot;quote&quot;, data);
</programlisting>
    <para>
      Publishing multiple rows is then just a case of increased length
      of each of the typed arrays:
    </para>
    <para>
      Example: <literal>TickPublisherExamples.java</literal>
    </para>
    <programlisting language="java">
String[] sym = new String[] {&quot;IBM&quot;, &quot;GE&quot;};
double[] bid = new double[] {100.25, 120.25};
double[] ask = new double[] {100.26, 120.26};
int[] bSize = new int[]{1000, 2000};
int[] aSize = new int[]{1000, 2000};
</programlisting>
    <para>
      In order to maximize tickerplant throughput and efficiency, it is
      generally recommended to publish multiple rows in one go.
    </para>
    <para>
      <i class="fa fa-hand-o-right"></i> whitepaper
      <link xlink:href="/wp/kdbtick_profiling_for_throughput_optimization.pdf"><emphasis>Kdb+tick
      Profiling for Throughput Optimization</emphasis></link>.
    </para>
    <para>
      Care has to be taken here to ensure that all typed arrays maintain
      the same length, as failure to do so will likely result in a kdb+
      type error. Such errors are especially troublesome when using
      asynchronous methods, which will not return
      <literal>KExceptions</literal> in the same manner as sync methods!
      It is also worth noting that the order of the typed arrays within
      the object array should match that of the table schema.
    </para>
  </section>
  <section xml:id="adding-a-timespan-column">
    <title>Adding a timespan column</title>
    <para>
      It is standard tickerplant functionality to append a timespan
      column to each row received from a feed handler if not included
      with the data passed, which is used to record when the data was
      received by the tickerplant. It’s possible for the publisher to
      create the timespan column to prevent the tickerplant from adding
      one:
    </para>
    <para>
      Example: <literal>TickPublisherExamples.java</literal>
    </para>
    <programlisting language="java">
//Timespan can be added here
c.Timespan[] time = new c.Timespan[] {new c.Timespan()};
String[] sym = new String[] {&quot;GS&quot;};
double[] bid = new double[] {100.25};
double[] ask = new double[] {100.26};
int[] bSize = new int[]{1000};
int[] aSize = new int[]{1000};
//Timespan array is then added at beginning of Object array
Object[] data = new Object[] {time, sym, bid, ask, bSize, aSize};
qConnection.ks(&quot;.u.upd&quot;, &quot;quote&quot;, data);
</programlisting>
    <para>
      This might be done, for example, to allow the feedhandler to
      define the time differently than simply logging the time at which
      the tickerplant receives the data.
    </para>
  </section>
</section>
<section xml:id="connecting-from-kdb-to-a-java-process">
  <title>Connecting from kdb+ to a Java process</title>
  <para>
    The examples thus far have emphasized interfacing between Java and
    kdb+ very much from the perspective of a Java client connecting to a
    kdb+ server, using the constructors relevant to this purpose. It is
    very much possible to reverse these roles using the
    <literal>c(Serversocket)</literal> constructor, which enables a Java
    process to listen for incoming kdb+ messages on the specified port.
  </para>
  <para>
    While the use cases for this <quote>server</quote> mode of operation
    are not as common as they might be for <quote>client</quote>-mode
    connections, it is nevertheless available to developers as a means
    of implementing communication between Java and kdb+ processes. The
    following examples demonstrate the basic mechanisms by which this
    can be done.
  </para>
  <section xml:id="handling-a-single-connection">
    <title>Handling a single connection</title>
    <para>
      To set this up, a <literal>c</literal> object is instantiated
      using the <quote>server</quote> mode constructor. This will listen
      to the incoming connection of a single kdb+ process:
    </para>
    <para>
      Example: <literal>IncomingConnectionExample.java</literal>
    </para>
    <programlisting language="java">
//Wait for incoming connection
System.out.println(&quot;Waiting for incoming connection on port 5001..&quot;);
c incomingConnection = new c(new ServerSocket(5001));
</programlisting>
    <para>
      In a manner similar to tickerplant subscription, the method
      <literal>k()</literal> (without parameters) can be used to wait on
      and listen to any connecting q session. In this example, the
      object is retrieved in this fashion and deciphered, either to
      return an error when passed the symbol
      <literal>`returnError</literal> or to return a message describing
      what was sent:
    </para>
    <para>
      Example: <literal>IncomingConnectionExample.java</literal>
    </para>
    <programlisting language="java">
while(true) {
  //k() method will wait until the kdb+ process sends an object.
  Object incoming = incomingConnection.k();
  try {
    // check the incoming object and return something based on what it is
    if (incoming instanceof String &amp;&amp; ((String)incoming).equals(&quot;returnError&quot;)) {
      incomingConnection.ke(&quot;ReturningError!&quot;);
    } else if(incoming.getClass().isArray()) {
      // if list, use Arrays toString method
      incomingConnection.kr(&quot;The incoming list values are: &quot; + Arrays.toString((Object[])incoming));
    } else {
      incomingConnection.kr((&quot;The incoming message was: &quot; + incoming.toString()).toCharArray());
    }
  } catch(IOException | KException e) {
    //return error responses too
      incomingConnection.ke(e.getMessage());
  }
}
</programlisting>
  </section>
  <section xml:id="handling-multiple-connections">
    <title>Handling multiple connections</title>
    <para>
      In the above example, the server <literal>c</literal> object is
      instantiated with a new ServerSocket being created in its
      constructor. This is acceptable in this instance because we cared
      only about the handling of one connection.
    </para>
    <para>
      In general, ServerSocket objects should not be used in this
      manner, as they are designed to handle more than a single incoming
      connection. Instead, the ServerSocket should be passed as a
      reference. With the addition of some simple threading, an
      application capable of handling messages from multiple q sessions
      can be created:
    </para>
    <para>
      Example: <literal>IncomingConnectionsExample.java</literal>
    </para>
    <programlisting language="java">
//Create server socket reference beforehand..
ServerSocket serverSocket = new ServerSocket(5001);

//Set up connection loop
while(true) {   
  //Create c object with reference to server socket
  final c incomingConnection = new c(serverSocket);

  //Create thread for handling this connection
  new Thread(new Runnable() {   
    @Override
    public void run() {
      while(true) {
        //Logic in this loop is similar to single connection 
        //[...]     
      } 
    }
  //Run thread and restart loop.
  }).start();
}
</programlisting>
    <para>
      This will allow any number of connections to be established, with
      factors such as connection limitation and load balancing left up
      to how the process is implemented. As in any case where threading
      is used, take care that such a method does not enable race
      conditions or concurrency issues; if necessary, steps can be taken
      to reduce the risk of such operations, such as synchronized blocks
      and methods.
    </para>
  </section>
</section>
<section xml:id="conclusion">
  <title>Conclusion</title>
  <para>
    This document has covered a variety of topics concerning the
    mechanics and application of the <literal>c.java</literal> interface
    for kdb+. Of the workings and examples shown, the most common use
    case for this interface will be connecting to a q process, executing
    queries and functions and managing any result objects. However, this
    document has also displayed the versatile nature of
    <literal>c.java</literal> as a tool, providing a handful of
    solutions to a given problem and able to fulfill server as well as
    client functions.
  </para>
  <para>
    The practical examples should also help demonstrate that tasks
    required as part of a standard kdb+ toolset can be handled easily
    from the perspective of both Java developers interfacing with kdb+
    for the first time, or kdb+ developers who are required to venture
    into Java development, for example, to help complete development of
    a feed handler. The benefit of such interfaces is felt keenly
    through the common role of these developers in helping to reconcile
    longstanding applications with contemporary technologies, often to
    the benefit of both.
  </para>
  <section xml:id="author">
    <title>Author</title>
    <para>
      Peter Lyness
    </para>
  </section>
</section>
</article>
